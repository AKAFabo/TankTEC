/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package Game;

import com.mycompany.tanktec.Enemies.EnemyTank;
import com.mycompany.tanktec.GeneralTank;
import com.mycompany.tanktec.Player.Tank;
import com.mycompany.tanktec.Wall;
import com.mycompany.tanktec.levelBuilder;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import javax.swing.Timer;
import Configuration.Configuration;
import Tank.*;

/**
 *
 * @author Fabo
 */
public class GUI extends javax.swing.JFrame {
    boolean running = true;
    Game game;
    public GUI() {
        
        initializeImageMap();
        this.game = new Game(this);
        initComponents();
        initializeObservers();
        setBoard();
        
        GamePlayPanel.setFocusable(true);
        GamePlayPanel.requestFocusInWindow();
        GamePlayPanel.addKeyListener(new TankKeyListener());
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        GamePlayPanel = new javax.swing.JPanel();
        enemiesLeftLabel = new javax.swing.JLabel();
        playerLifesLabel = new javax.swing.JLabel();
        actualLevelLabel = new javax.swing.JLabel();
        wildcardLabel = new javax.swing.JLabel();
        startLevelButton = new javax.swing.JButton();
        nextLevelButton = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        shotsCounterLabel = new javax.swing.JLabel();
        powerUpsCounterLabel = new javax.swing.JLabel();
        destroyedTanksLabel = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(51, 51, 51));

        GamePlayPanel.setBackground(new java.awt.Color(0, 0, 0));

        javax.swing.GroupLayout GamePlayPanelLayout = new javax.swing.GroupLayout(GamePlayPanel);
        GamePlayPanel.setLayout(GamePlayPanelLayout);
        GamePlayPanelLayout.setHorizontalGroup(
            GamePlayPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 620, Short.MAX_VALUE)
        );
        GamePlayPanelLayout.setVerticalGroup(
            GamePlayPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 620, Short.MAX_VALUE)
        );

        enemiesLeftLabel.setText("Enemigos restantes: " +  game.getRemainingEnemies());

        playerLifesLabel.setText("Vidas restantes: " + game.getPlayerLifes());

        actualLevelLabel.setText("Nivel actual: " + game.getActualLevel());

        wildcardLabel.setText("Comodin actual:");

        startLevelButton.setText("Empezar nivel");
        startLevelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startLevelButtonActionPerformed(evt);
            }
        });

        nextLevelButton.setText("Siguiente nivel");
        nextLevelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextLevelButtonActionPerformed(evt);
            }
        });

        jButton1.setText("jButton1");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(GamePlayPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(276, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(enemiesLeftLabel)
                            .addComponent(playerLifesLabel)
                            .addComponent(actualLevelLabel)
                            .addComponent(wildcardLabel)
                            .addComponent(startLevelButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(nextLevelButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(powerUpsCounterLabel, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(destroyedTanksLabel, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(shotsCounterLabel, javax.swing.GroupLayout.Alignment.TRAILING))
                        .addGap(82, 82, 82))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(57, 57, 57)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(enemiesLeftLabel)
                    .addComponent(shotsCounterLabel))
                .addGap(65, 65, 65)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(playerLifesLabel)
                    .addComponent(powerUpsCounterLabel))
                .addGap(65, 65, 65)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(actualLevelLabel)
                    .addComponent(destroyedTanksLabel))
                .addGap(75, 75, 75)
                .addComponent(wildcardLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jButton1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(startLevelButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(nextLevelButton)
                .addGap(42, 42, 42))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(GamePlayPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void startLevelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startLevelButtonActionPerformed
        SwingUtilities.invokeLater(() -> {
            spawnTanks();
            GamePlayPanel.setFocusable(true);
            GamePlayPanel.requestFocusInWindow();
        });
    }//GEN-LAST:event_startLevelButtonActionPerformed

    private void nextLevelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextLevelButtonActionPerformed
        GamePlayPanel.setFocusable(true);
        GamePlayPanel.requestFocusInWindow();
        loadNextLevel();
        //GamePlayPanel.addKeyListener(new TankKeyListener());
    }//GEN-LAST:event_nextLevelButtonActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        //addPowerUpBoard();
        protectBase();
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        
        System.out.println(Thread.currentThread().getName());
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI().setVisible(true);
            }
        });
    }
    
    public void initializeObservers(){
        game.addShotsCounterLabel(shotsCounterLabel, "Shots Fired");
        game.addPowerUpsCounterLabel(powerUpsCounterLabel, "PowerUps Used");
        game.addDestroyedTanksLabel(destroyedTanksLabel, "Destroyed Tanks");
    }
    
    public void paintBoard(int[][] levelMatrix){
    
        // TODO hacer Backend
        
    }
    
    public void setBoard() {

        GamePlayPanel.setPreferredSize(new Dimension(620, 620));
       
        GridLayout gridLayout = new GridLayout(13, 13);
        GamePlayPanel.setLayout(gridLayout);
        
        levelMatrix = levelBuilder.levelChooser(actualLevel);

        for (int i = 0; i < 13; i++) {
            for (int j = 0; j < 13; j++) {
                              
                labels[i][j] = new JLabel();
                labels[i][j].setOpaque(true);
                
                int identifier = levelMatrix[i][j];
                ImageIcon imageIcon = imageMap.get(identifier);
                
                if (identifier != 0){
                    labels[i][j].setIcon(imageIcon);
                    if (identifier != 5){ //Si es arbol es transparente
                        hasWall[i][j] = true; //Se hace para verificar las colisiones a la hora de mover el tanque enemigo y propio
                        if (identifier == 4){
                            bricks[i][j] = new Wall();
                        }
                    } else {
                        hasGrass[i][j] = true;
                    }
                } else {
                    labels[i][j].setBackground(new java.awt.Color(0, 0, 0));
                }

                labels[i][j].setPreferredSize(new Dimension(labelSize, labelSize));

                GamePlayPanel.add(labels[i][j]);
            }
        }
        
        labels[TankY][TankX].setIcon(new ImageIcon(tank.getIcon())); 
        isTankInPlace[TankY][TankX] = true;
        tanks[TankY][TankX] = tank;
    }
    
    public void loadNextLevel() {
        actualLevel++;
        
        levelMatrix = levelBuilder.levelChooser(actualLevel);

        if (actualLevel <= maxLevel) {
            GamePlayPanel.removeAll();
            levelMatrix = levelBuilder.levelChooser(actualLevel);

            for (int i = 0; i < 13; i++) {
                for (int j = 0; j < 13; j++) {
                    labels[i][j] = new JLabel();
                    labels[i][j].setOpaque(true);
                    hasWall[i][j] = false;
                    hasGrass[i][j] = false;
                    isTankInPlace[i][j] = false;
                    bricks[i][j] = null;

                    int identifier = levelMatrix[i][j];
                    ImageIcon imageIcon = imageMap.get(identifier);

                    if (identifier != 0) {
                        labels[i][j].setIcon(imageIcon);
                        if (identifier != 5) {
                            hasWall[i][j] = true;
                            if (identifier == 4){
                                bricks[i][j] = new Wall();
                            } else if (identifier == 1){
                                labels[i][j].setIcon(null);
                                labels[i][j].setBackground(new java.awt.Color(0, 0, 128));
                            }
                        } else {
                            hasGrass[i][j] = true;
                        }
                    } else {
                        labels[i][j].setBackground(new java.awt.Color(0, 0, 0));
                    }
                    labels[i][j].setPreferredSize(new Dimension(labelSize, labelSize));
                    GamePlayPanel.add(labels[i][j]);
                }
            }
            GamePlayPanel.revalidate();
            GamePlayPanel.repaint();
            
            TankY = 12;
            TankX = 4;

            labels[TankY][TankX].setIcon(new ImageIcon(tank.getIcon()));
            isTankInPlace[TankY][TankX] = true;
            tanks[TankY][TankX] = tank;
        }
    }
          
    private void initializeImageMap() {
        imageMap.put(1, new ImageIcon("src/main/resources/water.jpg"));
        imageMap.put(2, new ImageIcon("src/main/resources/metalWall.jpg"));
        imageMap.put(3, new ImageIcon("src/main/resources/home.jpg"));
        imageMap.put(4, new ImageIcon("src/main/resources/brickWall.jpg"));
        imageMap.put(5, new ImageIcon("src/main/resources/tree.jpg"));
    }

    public void protectBase() {
        bricks[11][5] = new Wall();
        hasWall[11][5] = true;
        levelMatrix[11][5] = 4;
        labels[11][5].setIcon(new ImageIcon("src/main/resources/metalWall.jpg"));
        
        bricks[11][6] = new Wall();
        hasWall[11][6] = true;
        levelMatrix[11][6] = 4;
        labels[11][6].setIcon(new ImageIcon("src/main/resources/metalWall.jpg"));
        
        bricks[11][7] = new Wall();
        hasWall[11][7] = true;
        levelMatrix[11][7] = 4;
        labels[11][7].setIcon(new ImageIcon("src/main/resources/metalWall.jpg"));
        
        bricks[12][5] = new Wall();
        hasWall[12][5] = true;
        levelMatrix[12][5] = 4;
        labels[12][5].setIcon(new ImageIcon("src/main/resources/metalWall.jpg"));
        
        bricks[12][7] = new Wall();
        hasWall[12][7] = true;
        levelMatrix[12][7] = 4;
        labels[12][7].setIcon(new ImageIcon("src/main/resources/metalWall.jpg"));
    }

    public void unprotectBase() {
        bricks[11][5] = new Wall();
        hasWall[11][5] = true;
        levelMatrix[11][5] = 5;
        labels[11][5].setIcon(new ImageIcon("src/main/resources/brickWall.jpg"));
        
        bricks[11][6] = new Wall();
        hasWall[11][6] = true;
        levelMatrix[11][6] = 5;
        labels[11][6].setIcon(new ImageIcon("src/main/resources/brickWall.jpg"));
        
        bricks[11][7] = new Wall();
        hasWall[11][7] = true;
        levelMatrix[11][7] = 5;
        labels[11][7].setIcon(new ImageIcon("src/main/resources/brickWall.jpg"));
        
        bricks[12][5] = new Wall();
        hasWall[12][5] = true;
        levelMatrix[12][5] = 5;
        labels[12][5].setIcon(new ImageIcon("src/main/resources/brickWall.jpg"));
        
        bricks[12][7] = new Wall();
        hasWall[12][7] = true;
        levelMatrix[12][7] = 5;
        labels[12][7].setIcon(new ImageIcon("src/main/resources/brickWall.jpg"));
    }
    
    private class TankKeyListener implements KeyListener {
        @Override
        public void keyPressed(KeyEvent e) {
            int keyCode = e.getKeyCode();

            new Thread(() -> {
                switch (keyCode) {
                    case KeyEvent.VK_W -> moveTank(-1, 0, 'W');
                    case KeyEvent.VK_S -> moveTank(1, 0, 'S');
                    case KeyEvent.VK_A -> moveTank(0, -1, 'A');
                    case KeyEvent.VK_D -> moveTank(0, 1, 'D');
                    case KeyEvent.VK_SPACE -> shootBullet(tank);
                }
            }).start();
        }
        @Override
        public void keyReleased(KeyEvent e) {
            // Puedes agregar lógica adicional aquí si es necesario
        }
        @Override
        public void keyTyped(KeyEvent e) {
            // Puedes agregar lógica adicional aquí si es necesario
        }
    }
    
    private synchronized void moveTank(int deltaY, int deltaX, char key) {
        int newTankX = TankX + deltaX;
        int newTankY = TankY + deltaY;
        tank.setDirection(key);
        
        if (isValidMovement(newTankY, newTankX)) {
            isTankInPlace[TankY][TankX] = false;
            tanks[TankY][TankX] = null;
            isTankInPlace[newTankY][newTankX] = true;
            tanks[newTankY][newTankX] = tank;

        boolean originalHasGrass = hasGrass[TankY][TankX];

        if (originalHasGrass) {
                labels[TankY][TankX].setBackground(new Color(0, 128, 0)); 
            } else {
                labels[TankY][TankX].setIcon(null);
        }

        TankY = newTankY;
        TankX = newTankX;

        switch (key) {
            case 'W' -> tank.setIcon("src/main/resources/tankU.gif");
            case 'A' -> tank.setIcon("src/main/resources/tankL.gif");
            case 'S' -> tank.setIcon("src/main/resources/tankD.gif");
            case 'D' -> tank.setIcon("src/main/resources/tankR.gif");
        }

        boolean newHasGrass = hasGrass[TankY][TankX];

        if (newHasGrass) {
            labels[TankY][TankX].setBackground(new Color(0, 128, 0)); 
        } else {
            labels[TankY][TankX].setIcon(new ImageIcon(tank.getIcon()));
        }
        
        if (hasPowerUp[TankX][TankY]) {

            PowerUp powerUp = powerUps[TankX][TankY];

            powerUp.start();

            powerUps[TankX][TankY] = null;
            hasPowerUp[TankX][TankY] = false;
            labels[TankX][TankY].setIcon(null);
            game.increasePowerUp();
            
        }
        }
     
    }
    
    private synchronized void shootBullet(Object tankObject) {
        final char tankDirection;
        final int bulletX;
        final int bulletY;
        final String shooter;
            if (tankObject instanceof Tank) {
                game.increaseShots();
                tankDirection = ((Tank) tankObject).getDirection();
                bulletX = TankX;
                bulletY = TankY;
                shooter = "player";
            } else if (tankObject instanceof EnemyTank) {
                tankDirection = ((EnemyTank) tankObject).getDirection();
                bulletX = ((EnemyTank) tankObject).getX();
                bulletY = ((EnemyTank) tankObject).getY();
                shooter = "enemy";
            }  else {
                tankDirection = 'N'; 
                bulletX = 0;
                bulletY = 0;
                shooter = "";
            }      
        
        new Thread(() -> {    
            String shooterType = shooter;
            int currentBulletX = bulletX;
            int currentBulletY = bulletY;
            String bulletDirection = null;
            
            switch (tankDirection) {
                        case ('W') -> {
                            currentBulletY--;
                            bulletDirection = bulletU;
                        }                                                 
                        case ('S') -> {
                            currentBulletY++;     
                            bulletDirection = bulletD;
                        }                                           
                        case ('A') -> {
                            currentBulletX--;           
                            bulletDirection = bulletL;
                        }
                        case ('D') -> {
                            currentBulletX++;
                            bulletDirection = bulletR;
                        }                       
                    }

            while (true) {
                
                try {
                    Thread.sleep(250);                   

                    // Actualizar la posición de la bala en la interfaz gráfica
                    final int finalBulletX = currentBulletX;
                    final int finalBulletY = currentBulletY;
                    labels[finalBulletY][finalBulletX].setIcon(new ImageIcon(bulletDirection));
                    GeneralTank tank = tanks[finalBulletY][finalBulletX];
                    
                    if (isTankInPlace[finalBulletY][finalBulletX]){
                        if (shooterType.equals("enemy") && tank instanceof Tank){
                            tank.takeDamage(); 
                            if(tanks[finalBulletY][finalBulletX].getHealth() == 0){
                                labels[finalBulletY][finalBulletX].setIcon(null);
                                labels[finalBulletY][finalBulletX].setBackground(new java.awt.Color(0, 0, 0));
                                hasWall[finalBulletY][finalBulletX] = false;
                                tanks[finalBulletY][finalBulletX] = null;
                                isTankInPlace[finalBulletY][finalBulletX] = false;
                                JOptionPane.showMessageDialog(null, "Nivel perdido");
                                GUI g = new GUI();
                                g.setVisible(true);
                                this.dispose();
                                
                            }
                        }
                    }
                                                        
                    if (hasWall[finalBulletY][finalBulletX] && levelMatrix[finalBulletY][finalBulletX] != 1 &&
                            levelMatrix[finalBulletY][finalBulletX] != 5) {
                        if (levelMatrix[finalBulletY][finalBulletX] == 4){  
                            bricks[finalBulletY][finalBulletX].takeDamage();
                            labels[finalBulletY][finalBulletX].setIcon(new ImageIcon("src/main/resources/brickWall.jpg"));
                            
                            if (bricks[finalBulletY][finalBulletX].getHealth() == 0){
                                labels[finalBulletY][finalBulletX].setIcon(null);
                                labels[finalBulletY][finalBulletX].setBackground(new java.awt.Color(0, 0, 0));
                                hasWall[finalBulletY][finalBulletX] = false;
                            }                            
                            
                        } else if (isTankInPlace[finalBulletY][finalBulletX]){                            
                            if (shooterType.equals("player") && (tank instanceof EnemyTank)) {
                                tank.takeDamage();
                            }


                            labels[finalBulletY][finalBulletX].setIcon(new ImageIcon(tanks[finalBulletY][finalBulletX].getIcon()));
                            
                            if(tanks[finalBulletY][finalBulletX].getHealth() == 0){
                                labels[finalBulletY][finalBulletX].setIcon(null);
                                labels[finalBulletY][finalBulletX].setBackground(new java.awt.Color(0, 0, 0));
                                hasWall[finalBulletY][finalBulletX] = false;
                                tanks[finalBulletY][finalBulletX] = null;
                                isTankInPlace[finalBulletY][finalBulletX] = false;
                                game.increaseDestroyTanks();
                                if ((tank instanceof EnemyTank) && ((EnemyTank) tank).getHasPowerUp()) {
                                    addPowerUpBoard();
                                }
                            }
                            
                        }else{
                            switch (levelMatrix[finalBulletY][finalBulletX]){
                                case (2) -> {
                                    labels[finalBulletY][finalBulletX].setIcon(new ImageIcon("src/main/resources/metalWall.jpg"));
                                }
                                case (3) -> {
                                    labels[finalBulletY][finalBulletX].setBackground(new java.awt.Color(0, 0, 0));  
                                    JOptionPane.showMessageDialog(null, "Nivel perdido");
                                    GUI g = new GUI();
                                    g.setVisible(true);
                                    this.dispose();
                                }
                            } 
                        }
                        switch (tankDirection) {
                            case ('W') -> {
                                labels[finalBulletY+1][finalBulletX].setIcon(null);
                            }
                            case ('S') -> {
                                labels[finalBulletY-1][finalBulletX].setIcon(null);
                            }
                            case ('A') -> {
                                labels[finalBulletY][finalBulletX+1].setIcon(null);
                            }                       
                            case ('D') -> {
                                labels[finalBulletY][finalBulletX-1].setIcon(null);
                            }
                        }
                        break;
                    }
                    
                    if (levelMatrix[finalBulletY][finalBulletX] == 5){
                        labels[finalBulletY][finalBulletX].setIcon(null);
                        labels[finalBulletY][finalBulletX].setBackground(new java.awt.Color(0, 128, 0));
                    }
                    
                    switch (tankDirection) {
                        case ('W') -> {
                            if (!isTankInPlace[finalBulletY+1][finalBulletX]){
                                labels[finalBulletY+1][finalBulletX].setIcon(null);
                            }
                            currentBulletY--;
                        }
                        case ('S') -> {
                            if (!isTankInPlace[finalBulletY-1][finalBulletX]){
                                labels[finalBulletY-1][finalBulletX].setIcon(null);
                            }
                            currentBulletY++;
                        }
                        case ('A') -> {
                            if (!isTankInPlace[finalBulletY][finalBulletX+1]){
                                labels[finalBulletY][finalBulletX+1].setIcon(null);
                            }
                            currentBulletX--;
                        }                       
                        case ('D') -> {
                            if (!isTankInPlace[finalBulletY][finalBulletX-1]){
                                labels[finalBulletY][finalBulletX-1].setIcon(null);
                            }
                            currentBulletX++;
                        }
                    }

                    if (currentBulletY < 0 || currentBulletY >= 13 || currentBulletX < 0 || currentBulletX >= 13) {
                        labels[finalBulletY][finalBulletX].setIcon(null);
                        break;
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }
    
    private boolean isValidMovement(int y, int x){
        return y >= 0 && y < labels.length && x >= 0 && x < labels[0].length && !hasWall[y][x];
    }
    
    public boolean placeEmpty(int x, int y){
        if (hasWall[x][y]) {
            return false;
        }
        if (hasGrass[x][y]) {
            return false;
        }
        if(isTankInPlace[x][y]){
            return false;
        }
        if(hasPowerUp[x][y]){
            return false;
        }
        return true;
    }
    
    public void addPowerUpBoard(){
        Random random = new Random();
        int randomX = random.nextInt(boardSize);
        int randomY = random.nextInt(boardSize);
        
        while(!placeEmpty(randomX, randomY)){
            randomX = random.nextInt(boardSize);
            randomY = random.nextInt(boardSize);
        }
        
        hasPowerUp[randomX][randomY] = true;
        labels[randomX][randomY].setIcon(new ImageIcon("src/main/resources/hp.png"));
        
        int number = 3;  //random.nextInt(6);
        
        switch (number) {
            case 0:
                powerUps[randomX][randomY] = new ClockPowerUp(this);
                break;
            case 1:
                powerUps[randomX][randomY] = new BombPowerUp(this);
                break;
            case 2:
                powerUps[randomX][randomY] = new HelmetPowerUp(this);
                break;
            case 3:
                System.out.println("Game.GUI.addPowerUpBoard() dfsd");
                powerUps[randomX][randomY] = new ShovelPowerUp(this);
                break;
            case 4:
                powerUps[randomX][randomY] = new StartPowerUp(this);
                break;
            case 5:
                powerUps[randomX][randomY] = new TankPowerUp(this);
                break;
            default:
                throw new AssertionError();
        }
        
    }

    
    public synchronized void spawnTanks() {
        new Thread(() -> {
            Random random = new Random();

            for (int i = 0; i < 4; i++) {
                int randomX = random.nextInt(boardSize);
                
                int possibility = random.nextInt(10);
                
                EnemyTank e;
                if (possibility != 9) {
                    e = new EnemyTank("src/main/resources/RedTankD.gif", 2, randomX, 'S', true);
                } else{
                    e = new EnemyTank("src/main/resources/GreenTankD.gif", 2, randomX, 'S', false);
                }
                

                SwingUtilities.invokeLater(() -> {
                    if (!hasWall[0][randomX]) {
                        labels[0][randomX].setIcon(new ImageIcon(e.getIcon()));
                        isTankInPlace[0][randomX] = true;
                        hasWall[0][randomX] = true;
                        tanks[0][randomX] = e;
                        moveEnemyTank(e);
                        enemiesLeft++;
                        game.setRemainingEnemies(enemiesLeft);
                        enemiesLeftLabel.setText("Remaining enemies: " + game.getRemainingEnemies());
                    }
                });

                try {
                    // Sleep for 1 second
                    Thread.sleep(1000);
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                    Thread.currentThread().interrupt();
                }
            }
            
        }).start();
    }

    public synchronized void moveEnemyTank(EnemyTank enemy) {
            
        new Thread(() -> {                      
            while (true){
                char enemyDirection = enemy.getDirection();
                int deltaX = 0, deltaY = 0;
                char possibleDirection = 'A';

                try {
                    Thread.sleep(1700);

                switch (enemyDirection){
                    case ('W') -> {
                        deltaY = -1;
                        possibleDirection = 'D';
                    }
                    case ('S') -> {
                        deltaY = 1;
                        possibleDirection = 'A';
                    }
                    case ('A') -> {
                        deltaX = -1;           
                        possibleDirection = 'W';
                    }
                    case ('D') -> {
                        possibleDirection = 'S';
                        deltaX = 1;
                    }
                }
                int newX = enemy.getX() + deltaX;
                int newY = enemy.getY() + deltaY;
                
                if (isValidMovement(newY, newX)){
                    isTankInPlace[enemy.getY()][enemy.getX()] = false;
                    tanks[enemy.getY()][enemy.getX()]= null;
                    isTankInPlace[newY][newX] = true;
                    tanks[newY][newX] = enemy;
                    labels[enemy.getY()][enemy.getX()].setIcon(null);
                    hasWall[enemy.getY()][enemy.getX()] = false;
                    hasWall[newY][newX] = true;
                    enemy.setX(newX);
                    enemy.setY(newY);
                    
                                       
                    boolean originalHasGrass = hasGrass[TankY][TankX];

                    if (originalHasGrass) {
                        labels[enemy.getY()][enemy.getX()].setBackground(new Color(0, 128, 0)); 
                    } else {
                        labels[enemy.getY()][enemy.getX()].setIcon(null);
                    }
                    
                    boolean newHasGrass = hasGrass[TankY][TankX];

                    if (newHasGrass) {
                        labels[newY][newX].setBackground(new Color(0, 128, 0)); 
                    } else {
                        labels[newY][newX].setIcon(new ImageIcon(enemy.getIcon()));
                    }
                    
                    Thread.sleep(500);
                    shootBullet(enemy);
                    
                } else {
                    enemy.setDirection(possibleDirection);
                }
                if (!enemy.getHasPowerUp()) {
                    switch (enemy.getDirection()) {
                        case 'W' -> enemy.setIcon("src/main/resources/GreenTankU.gif");
                        case 'A' -> enemy.setIcon("src/main/resources/GreenTankL.gif");
                        case 'S' -> enemy.setIcon("src/main/resources/GreenTankD.gif");
                        case 'D' -> enemy.setIcon("src/main/resources/GreenTankR.gif");
                    }
                } else{
                    switch (enemy.getDirection()) {
                        case 'W' -> enemy.setIcon("src/main/resources/RedTankU.gif");
                        case 'A' -> enemy.setIcon("src/main/resources/RedTankL.gif");
                        case 'S' -> enemy.setIcon("src/main/resources/RedTankD.gif");
                        case 'D' -> enemy.setIcon("src/main/resources/RedTankR.gif");
                    } 
                }

                
                if (enemy.getHealth() == 0){
                    isTankInPlace[enemy.getY()][enemy.getX()] = false;
                    tanks[enemy.getY()][enemy.getX()]= null;
                    labels[enemy.getY()][enemy.getX()].setIcon(null);
                    hasWall[enemy.getY()][enemy.getX()] = false;
                    enemy.setIcon("");                   
                    System.out.println("Muerto");
                    
                    game.tankKilled();
                    enemiesLeftLabel.setText("Remaining enemies: " + game.getRemainingEnemies());
                    enemiesLeft--;
                    
                    if (enemiesLeft == 0){
                        JOptionPane.showMessageDialog(null, "Stage completed");
                    }
                    break;
                }
                Thread.sleep(250);
                
                
            }   catch (InterruptedException ex) {
                    Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
                }

            }
        }).start();
    }

    Configuration config = Configuration.getInstance();
    int boardSize = config.getConfigValue("boardSize");

    private JLabel[][] labels = new JLabel[boardSize][boardSize];
    private boolean[][] hasWall = new boolean[boardSize][boardSize];
    private boolean[][] hasGrass = new boolean[boardSize][boardSize];
    private boolean[][] hasPowerUp = new boolean[boardSize][boardSize];
    private PowerUp[][] powerUps = new PowerUp[boardSize][boardSize];
    private boolean[][] isTankInPlace = new boolean[boardSize][boardSize];
    private Wall[][] bricks = new Wall[boardSize][boardSize];
    private ArrayList<EnemyTank> enemies = new ArrayList<>();
    private GeneralTank[][] tanks = new GeneralTank[boardSize][boardSize];
    
    private int enemiesLeft;
    private int playerLifes = 3;
    private int actualLevel = 1;
    private int maxLevel = 8;
    private int TankX = 4;
    private int TankY = 12;
    int labelSize = 620 / 13;
    
    private Map<Integer, ImageIcon> imageMap = new HashMap<>(); 
    private int[][] levelMatrix;
    
    private final String bulletU = "src/main/resources/bulletU.gif";
    private final String bulletD = "src/main/resources/bulletD.gif";
    private final String bulletL = "src/main/resources/bulletL.gif";
    private final String bulletR = "src/main/resources/bulletR.gif";
    
    Tank tank = new Tank("src/main/resources/tankU.gif", 1, 'W');
    
    
    
    Timer movementTimer;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel GamePlayPanel;
    private javax.swing.JLabel actualLevelLabel;
    private javax.swing.JLabel destroyedTanksLabel;
    private javax.swing.JLabel enemiesLeftLabel;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton nextLevelButton;
    private javax.swing.JLabel playerLifesLabel;
    private javax.swing.JLabel powerUpsCounterLabel;
    private javax.swing.JLabel shotsCounterLabel;
    private javax.swing.JButton startLevelButton;
    private javax.swing.JLabel wildcardLabel;
    // End of variables declaration//GEN-END:variables
}