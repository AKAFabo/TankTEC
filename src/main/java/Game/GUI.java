/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package Game;

import com.mycompany.tanktec.Enemies.EnemyTank;
import com.mycompany.tanktec.Player.Tank;
import com.mycompany.tanktec.Wall;
import com.mycompany.tanktec.levelBuilder;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.SwingUtilities;
import javax.swing.Timer;

/**
 *
 * @author Fabo
 */
public class GUI extends javax.swing.JFrame {

    Game game;
    public GUI() {
        
        initializeImageMap();
        this.game = new Game(this);
        initComponents();
        setBoard();
        
        GamePlayPanel.setFocusable(true);
        GamePlayPanel.requestFocusInWindow();
        GamePlayPanel.addKeyListener(new TankKeyListener());
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        GamePlayPanel = new javax.swing.JPanel();
        enemiesLeftLabel = new javax.swing.JLabel();
        playerLifesLabel = new javax.swing.JLabel();
        actualLevelLabel = new javax.swing.JLabel();
        wildcardLabel = new javax.swing.JLabel();
        startLevelButton = new javax.swing.JButton();
        nextLevelButton = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(51, 51, 51));

        GamePlayPanel.setBackground(new java.awt.Color(0, 0, 0));

        javax.swing.GroupLayout GamePlayPanelLayout = new javax.swing.GroupLayout(GamePlayPanel);
        GamePlayPanel.setLayout(GamePlayPanelLayout);
        GamePlayPanelLayout.setHorizontalGroup(
            GamePlayPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 620, Short.MAX_VALUE)
        );
        GamePlayPanelLayout.setVerticalGroup(
            GamePlayPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 620, Short.MAX_VALUE)
        );

        enemiesLeftLabel.setText("Enemigos restantes: " +  game.getRemainingEnemies());

        playerLifesLabel.setText("Vidas restantes: " + game.getPlayerLifes());

        actualLevelLabel.setText("Nivel actual: " + game.getActualLevel());

        wildcardLabel.setText("Comodin actual:");

        startLevelButton.setText("Empezar nivel");
        startLevelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startLevelButtonActionPerformed(evt);
            }
        });

        nextLevelButton.setText("Siguiente nivel");
        nextLevelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextLevelButtonActionPerformed(evt);
            }
        });

        jButton1.setText("jButton1");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(GamePlayPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(enemiesLeftLabel)
                        .addComponent(playerLifesLabel)
                        .addComponent(actualLevelLabel)
                        .addComponent(wildcardLabel)
                        .addComponent(startLevelButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(nextLevelButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(59, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(57, 57, 57)
                .addComponent(enemiesLeftLabel)
                .addGap(65, 65, 65)
                .addComponent(playerLifesLabel)
                .addGap(65, 65, 65)
                .addComponent(actualLevelLabel)
                .addGap(75, 75, 75)
                .addComponent(wildcardLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jButton1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(startLevelButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(nextLevelButton)
                .addGap(42, 42, 42))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(GamePlayPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void startLevelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startLevelButtonActionPerformed
        SwingUtilities.invokeLater(() -> {
            spawnTanks();
            GamePlayPanel.setFocusable(true);
            GamePlayPanel.requestFocusInWindow();
        });
    }//GEN-LAST:event_startLevelButtonActionPerformed

    private void nextLevelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextLevelButtonActionPerformed
        GamePlayPanel.setFocusable(true);
        GamePlayPanel.requestFocusInWindow();
        loadNextLevel();
        //GamePlayPanel.addKeyListener(new TankKeyListener());
    }//GEN-LAST:event_nextLevelButtonActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        
        System.out.println(Thread.currentThread().getName());
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI().setVisible(true);
            }
        });
    }
    
    public void paintBoard(int[][] levelMatrix){
    
    }
    
    public void setBoard() {

        GamePlayPanel.setPreferredSize(new Dimension(620, 620));
       
        GridLayout gridLayout = new GridLayout(13, 13);
        GamePlayPanel.setLayout(gridLayout);
        
        levelMatrix = levelBuilder.levelChooser(actualLevel);

        for (int i = 0; i < 13; i++) {
            for (int j = 0; j < 13; j++) {
                              
                labels[i][j] = new JLabel();
                labels[i][j].setOpaque(true);
                
                int identifier = levelMatrix[i][j];
                ImageIcon imageIcon = imageMap.get(identifier);
                
                if (identifier != 0){
                    labels[i][j].setIcon(imageIcon);
                    if (identifier != 5){ //Si es arbol es transparente
                        hasWall[i][j] = true; //Se hace para verificar las colisiones a la hora de mover el tanque enemigo y propio
                        if (identifier == 4){
                            bricks[i][j] = new Wall();
                        }
                    } else {
                        hasGrass[i][j] = true;
                    }
                } else {
                    labels[i][j].setBackground(new java.awt.Color(0, 0, 0));
                }

                labels[i][j].setPreferredSize(new Dimension(labelSize, labelSize));

                GamePlayPanel.add(labels[i][j]);
            }
        }
        
        labels[TankY][TankX].setIcon(new ImageIcon(tank.getIcon())); 
        isTankInPlace[TankY][TankX] = true;
    }
    
    public void loadNextLevel() {
        actualLevel++;
        System.out.println("Hola");
        
        levelMatrix = levelBuilder.levelChooser(actualLevel);

        if (actualLevel <= maxLevel) {
            GamePlayPanel.removeAll();

            for (int i = 0; i < 13; i++) {
                for (int j = 0; j < 13; j++) {
                    labels[i][j] = new JLabel();
                    labels[i][j].setOpaque(true);
                    hasWall[i][j] = false;
                    hasGrass[i][j] = false;
                    isTankInPlace[i][j] = false;
                    bricks[i][j] = null;

                    int identifier = levelMatrix[i][j];
                    ImageIcon imageIcon = imageMap.get(identifier);

                    if (identifier != 0) {
                        labels[i][j].setIcon(imageIcon);
                        if (identifier != 5) {
                            hasWall[i][j] = true;
                            if (identifier == 4){
                                bricks[i][j] = new Wall();
                            } else if (identifier == 1){
                                labels[i][j].setIcon(null);
                                labels[i][j].setBackground(new java.awt.Color(0, 0, 128));
                            }
                        } else {
                            hasGrass[i][j] = true;
                        }
                    } else {
                        labels[i][j].setBackground(new java.awt.Color(0, 0, 0));
                    }
                    labels[i][j].setPreferredSize(new Dimension(labelSize, labelSize));
                    GamePlayPanel.add(labels[i][j]);
                }
            }
            GamePlayPanel.revalidate();
            GamePlayPanel.repaint();
            
            TankY = 12;
            TankX = 4;

            labels[TankY][TankX].setIcon(new ImageIcon(tank.getIcon()));
            isTankInPlace[TankY][TankX] = true;
        }
    }
          
    private void initializeImageMap() {
        imageMap.put(1, new ImageIcon("src/main/resources/water.jpg"));
        imageMap.put(2, new ImageIcon("src/main/resources/metalWall.jpg"));
        imageMap.put(3, new ImageIcon("src/main/resources/home.jpg"));
        imageMap.put(4, new ImageIcon("src/main/resources/brickWall.jpg"));
        imageMap.put(5, new ImageIcon("src/main/resources/tree.jpg"));
    }
    
    private class TankKeyListener implements KeyListener {
        @Override
        public void keyPressed(KeyEvent e) {
            int keyCode = e.getKeyCode();

            new Thread(() -> {
                switch (keyCode) {
                    case KeyEvent.VK_W -> moveTank(-1, 0, 'W');
                    case KeyEvent.VK_S -> moveTank(1, 0, 'S');
                    case KeyEvent.VK_A -> moveTank(0, -1, 'A');
                    case KeyEvent.VK_D -> moveTank(0, 1, 'D');
                    case KeyEvent.VK_SPACE -> shootBullet();
                }
            }).start();
        }

        @Override
        public void keyReleased(KeyEvent e) {
            // Puedes agregar lógica adicional aquí si es necesario
        }

        @Override
        public void keyTyped(KeyEvent e) {
            // Puedes agregar lógica adicional aquí si es necesario
        }
    }

    
    private synchronized void moveTank(int deltaY, int deltaX, char key) {
        int newTankX = TankX + deltaX;
        int newTankY = TankY + deltaY;
        tank.setDirection(key);
        
        if (isValidMovement(newTankY, newTankX)) {
            
            isTankInPlace[TankY][TankX] = false;
            isTankInPlace[newTankY][newTankX] = true;

        boolean originalHasGrass = hasGrass[TankY][TankX];

        if (originalHasGrass) {
            labels[TankY][TankX].setBackground(new Color(0, 128, 0)); 
        } else {
            labels[TankY][TankX].setIcon(null);
        }

        TankY = newTankY;
        TankX = newTankX;

        switch (key) {
            case 'W' -> tank.setIcon("src/main/resources/tankU.gif");
            case 'A' -> tank.setIcon("src/main/resources/tankL.gif");
            case 'S' -> tank.setIcon("src/main/resources/tankD.gif");
            case 'D' -> tank.setIcon("src/main/resources/tankR.gif");
        }

        boolean newHasGrass = hasGrass[TankY][TankX];

        if (newHasGrass) {
            labels[TankY][TankX].setBackground(new Color(0, 128, 0)); 
        } else {
            labels[TankY][TankX].setIcon(new ImageIcon(tank.getIcon()));
        }
    }

        
    }
    
    private synchronized void shootBullet() {

        final int bulletX = TankX;
        final int bulletY = TankY;
        final char tankDirection = tank.getDirection();

        new Thread(() -> {
            
            
            int currentBulletX = bulletX;
            int currentBulletY = bulletY;
            String bulletDirection = null;
            
            switch (tankDirection) {
                        case ('W') -> {
                            currentBulletY--;
                            bulletDirection = bulletU;
                        }                                                 
                        case ('S') -> {
                            currentBulletY++;     
                            bulletDirection = bulletD;
                        }                                           
                        case ('A') -> {
                            currentBulletX--;           
                            bulletDirection = bulletL;
                        }
                        case ('D') -> {
                            currentBulletX++;
                            bulletDirection = bulletR;
                        }                       
                    }

            while (true) {
                try {
                    Thread.sleep(250);                   

                    // Actualizar la posición de la bala en la interfaz gráfica
                    final int finalBulletX = currentBulletX;
                    final int finalBulletY = currentBulletY;
                  
                    labels[finalBulletY][finalBulletX].setIcon(new ImageIcon(bulletDirection));
                                                        
                    if (hasWall[finalBulletY][finalBulletX] && levelMatrix[finalBulletY][finalBulletX] != 1 &&
                            levelMatrix[finalBulletY][finalBulletX] != 5) {
                        
                        if (levelMatrix[finalBulletY][finalBulletX] == 4){                           
                            bricks[finalBulletY][finalBulletX].takeDamage();
                            labels[finalBulletY][finalBulletX].setIcon(new ImageIcon("src/main/resources/brickWall.jpg"));
                            
                            if (bricks[finalBulletY][finalBulletX].getHealth() == 0){
                                labels[finalBulletY][finalBulletX].setIcon(null);
                                labels[finalBulletY][finalBulletX].setBackground(new java.awt.Color(0, 0, 0));
                                hasWall[finalBulletY][finalBulletX] = false;
                            }
                        } else {
                            switch (levelMatrix[finalBulletY][finalBulletX]){
                                case 2 -> labels[finalBulletY][finalBulletX].setIcon(new ImageIcon("src/main/resources/metalWall.jpg"));
                                case 3 -> labels[finalBulletY][finalBulletX].setBackground(new java.awt.Color(0, 0, 0));                                
                            }
                        }                       
                        switch (tankDirection) {
                            case ('W') -> {
                                labels[finalBulletY+1][finalBulletX].setIcon(null);
                            }
                            case ('S') -> {
                                labels[finalBulletY-1][finalBulletX].setIcon(null);
                            }
                            case ('A') -> {
                                labels[finalBulletY][finalBulletX+1].setIcon(null);
                            }                       
                            case ('D') -> {
                                labels[finalBulletY][finalBulletX-1].setIcon(null);
                            }
                        }
                        break;
                    }
                    
                    if (levelMatrix[finalBulletY][finalBulletX] == 5){
                        labels[finalBulletY][finalBulletX].setIcon(null);
                        labels[finalBulletY][finalBulletX].setBackground(new java.awt.Color(0, 128, 0));
                    }
                    
                    switch (tankDirection) {
                        case ('W') -> {
                            if (!isTankInPlace[finalBulletY+1][finalBulletX]){
                                labels[finalBulletY+1][finalBulletX].setIcon(null);
                            }
                            currentBulletY--;
                        }
                        case ('S') -> {
                            if (!isTankInPlace[finalBulletY-1][finalBulletX]){
                                labels[finalBulletY-1][finalBulletX].setIcon(null);
                            }
                            currentBulletY++;
                        }
                        case ('A') -> {
                            if (!isTankInPlace[finalBulletY][finalBulletX+1]){
                                labels[finalBulletY][finalBulletX+1].setIcon(null);
                            }
                            currentBulletX--;
                        }                       
                        case ('D') -> {
                            if (!isTankInPlace[finalBulletY][finalBulletX-1]){
                                labels[finalBulletY][finalBulletX-1].setIcon(null);
                            }
                            currentBulletX++;
                        }
                    }

                    if (currentBulletY < 0 || currentBulletY >= 13 || currentBulletX < 0 || currentBulletX >= 13) {
                        labels[finalBulletY][finalBulletX].setIcon(null);
                        break;
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }
    
    private boolean isValidMovement(int y, int x){
        return y >= 0 && y < labels.length && x >= 0 && x < labels[0].length && !hasWall[y][x];
    }
    
    public synchronized void spawnTanks() {
        new Thread(() -> {
            Random random = new Random();

            for (int i = 0; i < 20; i++) {
                int randomX = random.nextInt(13);
                EnemyTank e = new EnemyTank("src/main/resources/GreenTankD.gif", "", 2, 1000, 1000, randomX, 'S');
                enemies.add(e);

                SwingUtilities.invokeLater(() -> {
                    if (!hasWall[0][randomX]) {
                        labels[0][randomX].setIcon(new ImageIcon(e.getIcon()));
                        hasWall[0][randomX] = true;
                    }
                });

                try {
                    // Sleep for 1 second
                    Thread.sleep(1000);
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                    Thread.currentThread().interrupt();
                }
            }
            System.out.print(Thread.currentThread().getName());
        }).start();
    }
    private JLabel[][] labels = new JLabel[13][13];
    private boolean[][] hasWall = new boolean[13][13];
    private boolean[][] hasGrass = new boolean[13][13];
    private boolean[][] hasWater = new boolean[13][13];
    private boolean[][] isTankInPlace = new boolean[13][13];
    private Wall[][] bricks = new Wall[13][13];
    private ArrayList<EnemyTank> enemies = new ArrayList<>();
    
    private int enemiesLeft = 20;
    private int playerLifes = 3;
    private int actualLevel = 1;
    private int maxLevel = 8;
    private int TankX = 4;
    private int TankY = 12;
    int labelSize = 620 / 13;
    
    private Map<Integer, ImageIcon> imageMap = new HashMap<>(); 
    private int[][] levelMatrix;
    
    private final String bulletU = "src/main/resources/bulletU.gif";
    private final String bulletD = "src/main/resources/bulletD.gif";
    private final String bulletL = "src/main/resources/bulletL.gif";
    private final String bulletR = "src/main/resources/bulletR.gif";
    
    Tank tank = new Tank(500, "src/main/resources/tankU.gif", 1, 'W'); 
    
    Timer movementTimer;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel GamePlayPanel;
    private javax.swing.JLabel actualLevelLabel;
    private javax.swing.JLabel enemiesLeftLabel;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton nextLevelButton;
    private javax.swing.JLabel playerLifesLabel;
    private javax.swing.JButton startLevelButton;
    private javax.swing.JLabel wildcardLabel;
    // End of variables declaration//GEN-END:variables
}